Michelson Parsing and Execution Process
=======================================


Overview
--------

Reference Parser Process:

- string source --[ parse source into Micheline nodes ]--> Micheline nodes with annotations
- Micheline nodes with annotations --[ expand macros ]--> Michelson nodes with annotations
- Micheline ndoes --[ convert to Michelson primitives ]--> Michelson nodes with annotations

NOTE: scripts are stored as Michelson primitives

Execution process:

- Michelson nodes with annotations --[ script parser ]--> Michelson typed IR
- Michelson typed IR + ... --[ interpreter ]--> effects

Script parser does (simultaneously):

- annotation arity checking
- argument arity checking
- type checking


Miscellaneous Notes
-------------------

- Michelson strings are restricted to the printable ASCII subset;
  if more flexibility is need, a bytes type is required
- Michelson string,  map, and big_map literals must be written in sorted order
  with respect to the set elements or map keys
- Michelson source files are UTF-8 encoded
- There is no maximum literal or stack size --- but there is a maximum type size

Annotation Notes
----------------

### Overview

- Max annotation length is 255
- Even though not mentioned in Micheline spec, reference parser enforces annotations to come first
- Type annotations can be understood as newtypes
- Field annotations can be understood as product or union type element labels

### Annotations and type-checking

- Variable annotations _DO NOT DIRECTLY_ affect type checking _BUT_ field annotation `%@` converts var to field annotations
- Field annotations affect type checking _ONLY IF_ a CAR/CDR instruction is given a field annotation
- Type annotations _ALWAYS_ affect type checking

Special field `%@` and var `@%`, `@%%` annotations can be understood as _dynamically valued_ field and var annotations;
that is, they derive their value from the current field or var annotations in scope.

### Valid Annotation Locations

- Type annotations may be given to types, PUSH-like instructions, and CAST
- Field annotations may be given to type fields and the PAIR/LEFT/RIGHT/CAR/CDR instructions
- Variable annotations may be given to any instruction that pushes values on the stack and the no-op instruction RENAME

### Default Annotation Processing

NOTE: wildcard annotations are those without any suffix, i.e the three cases ( @ : % ), and are ignored except for their position

NOTE: some instructions will add variable annotations by default, even if no variable annotation is given

NOTE: no instruction will add type/field annotations by default when no type/field annotation is given

#### Default Variable Annoations

Default variable annotations are generated by certain instructions:

- blockchain specific PUSH-like instructions have default variable annotations based on blockchain context
- SLICE/PACK/UNPACK/ADDRESS/CONTRACT have special variable annotation produced based on stack context

- LOOP_LEFT produces var annotation on bound element - if input has var annotation "@x" will produce "@x.left"
- IF_LEFT produces var annotation on bound element - if input has var annotation "@x" will produce "@x.left" and "@x.right" on respective branches

- ITER (list/set) and MAP (list) instructions produce var annotation on bound element - either "@elt" if input has no var annotation OR "@x.elt" if input has var annotation "@x"
- IF_NONE produces var annotation on bound element - "@some" if input has no var annotation OR "@x.some" if input has var annotation "@x"
- IF_CONS produces var annotation on bound elements - "@hd" and "@tl" if input has no var annotation OR "@x.hd" "@x.tl" if input has var annotation "@x"

- ITER (map) and MAP (map) instructions produce var annotation on bound elements - "@key" and "@elt"

- LAMBDA and lambda literals produce var annotation on bound element - "@arg"

#### Special Annotation Processing

##### CAR/CDR Annotation Processing

Used function is 'parse_destr_annot' and special annotations are @% and @%%.

CAR/CDR produces var annotation on grabbed elements as follows:
- if given standard var annotation v, use v
- if given wildcard annotation OR not given standard var annotation and pair element has var annotation v, use v
- if given @% AND pair has corresponding field annotation f, use f
- if given @%%, there are several possibilities:
  - if pair has var annotation v
    - AND pair has corresponding field anntoation f - use v.f
    - AND pair has no corresponding field annotation, use v.car/cdr
  - if pair has no var annotation,
    - AND pair has no field annotation, do nothing
    - AND pair has field annotation f, use f

##### PAIR/LEFT/RIGHT Annotation Processing

Used function is 'parse_constr_annot' and special annotation is %@

PAIR produces a var annotation in the following manner:
- if var annotation given, use it
- if no var annotation given AND one or two special field annotations given, then:
  - if precisely one stack element has var annotation of form @p.x (with . the last dot), then use @p as the var annotation
  - if both stack elements have var annotations of the form @p.x and @p.y (with . the last dots), then use @p as the the var annotation
  - if both stack elemeens have var annotations but they do not agree, do not add var annotation

PAIR produces field annotations in the following manner:
- if standard field annotations are given, use them
- if special field annotation in (first,second) position given, then:
  - examine var annotation of (first,second) element in pair
  - if var annotation contains a dot, use suffix after the final dot as the field annotation
  - if var annotation contains no final dot, use entire var annotation as field annotation

LEFT/RIGHT produces var annotation in the following manner:
  - if var annotation given, use it
  - no var annotation and LEFT/RIGHT has special field annotation in first/second position respectively
    - if var annotation on data on stack top is of form @p.x (with . the last dot), then use @p as the var annotation
    - if var annotation on data on stack top has no dot, then do not add var annotation

LEFT/RIGHT produces field annotations in the following manner:
  - if standard field annotations given, use them
  - if LEFT/RIGHT has special field annotation in first/second position respectively
    - if var annotation on data on stack top is of form @p.x (with . the last dot), then use %x as the first/second field annotation
    - if var annotation on data on stack top has no dot, then use directly as first/second field annotation


### Annotation and Macro Processing

Annotations interact with macros. These macros can have annotations:

- DU+P  @var --- this is a deprecated version of DUP n
- DUP n @var --- duplicate the nth stack element
- CAD+R @var %field
- CMP[EQ|NEQ|LT|GT|LE|GE] @var
- SET_CAD+R @var %field
- MAP_CAD+R @var %field
- PAI+R
- UNPAI+R
- ASSERT_[SOME|LEFT|RIGHT] @var

These cannot:

- DXIIV+P --- this is a deprecated macro equivalent to DIP n instruction
- ASSERT / ASSERT_[EQ|NEQ|LT|GT|LE|GE] / ASSERT_CMP[EQ|NEQ|LT|GT|LE|GE] / ASSERT_NONE
- FAIL
- IF[EQ|NEQ|LT|GT|LE|GE] / IFCMP[EQ|NEQ|LT|GT|LE|GE] / IF_SOME / IF_RIGHT

Instruction Argument Arity
--------------------------

Instructions with variable argument arity:

- DIP { code }  / DIP n { code }
- DROP          / DROP n

NOTE: DUP n is a macro, so technically not a variable arity instruction

Michelson Reference Parsing and Execution Libraries and Flows
-------------------------------------------------------------

lib_micheline
  - micheline : defines
    1. micheline nodes `('location * 'type) node`
    2. canonical micheline nodes without location information `'type canonical`
    3. canonical_location represents expression positions to integers (used when textual source form isn't available) `int`
    4. annotations `type annot = string list`

  - micheline_parser : defines
    1. defines type synonym `type node = (location, string) Micheline.node`
    2. defines location as `type location = {start : point; stop : point}`
    3. defines `tokenize : string -> token list parsing_result`
    3. defines `parse_toplevel : ?check:bool -> token list -> node list parsing_result`

proto_x/lib_protocol
  - michelson_v1_primitives : defines michelson primitives and micheline to michelson primitive conversion
    1. defines michelson primitives as type `prim`
    2. defines `prims_of_strings` which converts `string canonical` to `prim canonical`

  - script_repr : defines Michelson script rerpresentation
    1. michelson nodes as `type node = (location, prim) node`
    2. canonical michelson nodes as `type expr = prim canonical`
    3. lazy expressions are expressions wrapped in a thunk `type lazy_expr`
    4. annotations are identical to micheline annotations

  - alpha_context : defines protocol context
    1. defines Script module
     - includes `Script_repr`
     - defines `Script.t = { code : lazy_expr; storage : lazy_expr}`

proto_x/lib_client
  - michelson_v1_macros : defines Michelson macro expansion over micheline nodes `(location * string) Micheline.node`
  - michelson_v1_parser : defines Michelson parser which converts source to `prim canonical`
    1. defines `type parsed = { source : string ; expanded : Script.expr ... }` where `expr` is `prim canonical`
    2. defines `parse_toplevel : ?check:bool -> string -> parsed parsing_result`
    3. defines `parse_expression : ?check:bool -> string -> parsed parsing_result`

proto_x/lib_protocol
  - script_typed_ir : defines IR for Michelson programs
    - IR Michelson data literals represented via GADT `ty`
    - IR Michelson instruction represented via GADT `instr`

  - script_ir_annot : defines default annotations and string to annotation parsers

  - script_ir_translator : defines Micheline nodes to typed IR conversion
    1. defines wrappers around IR types
      - comparable types as `ex_comparable_ty`
      - standard types as `ex_ty`
      - stack types as `ex_stack_ty`
      - scripts as `ex_script`
    2. defines script parser as `parse_script : ?type_logger -> context -> legacy:bool -> Script.t -> (ex_script * context) tzresult Lwt.t`
       NOTE: before `parse_script` can be executed, one needs a `Script.t` which is produced from calls to Michelson parser

  - script_interpreter : defines Michelson script interpreter
    1. execute - takes `Script.t` and executes it
