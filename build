#!/usr/bin/env python3

import os
import subprocess
import sys

# Bootstrapping
# =============

# Make sure the KNinja repo is available.
subprocess.check_call(['git', 'submodule', 'update', '--init', '--recursive'])

extdir = 'ext'
repodir = os.path.dirname(__file__)
sys.path.append(os.path.join(repodir, extdir))

from kninja import *
proj = KProject(extdir = extdir)

# Helpers
# =======

def topdir(*args): return os.path.join(os.path.dirname(os.path.realpath(__file__)), *args)
def ccopt(opt): return ['-ccopt', opt]

all_sources = [ 'michelson/common.md'
              , 'michelson/configuration.md'
              , 'michelson/internal-syntax.md'
              , 'michelson/michelson.md'
              , 'michelson/syntax.md'
              , 'michelson/types.md'
              , 'unit-test/syntax.md'
              , 'unit-test/unit-test.md'
              , 'symbolic/configuration.md'
              , 'symbolic/symbolic.md'
              , 'symbolic/syntax.md'
              , 'compat.md'
              ]
hook_sources = [ 'hooks/hex.cpp'
               , 'hooks/time.cpp'
               , 'hooks/decode.cpp'
               ]

llvm_flags = [ # This needs to be an absolute path because the kompile chdirs before resolving all paths.
               *ccopt('-I' + topdir(proj.kreleasedir('include/kllvm')))
             , *ccopt(topdir('hooks/hex.cpp'))
             , *ccopt(topdir('hooks/time.cpp'))
             , *ccopt(topdir('hooks/decode.cpp'))
             , *ccopt('-std=c++14')
             , '--gen-bison-parser'
             , '--hook-namespaces', 'TIME'
             , '--hook-namespaces', 'MICHELSON'
             ]

def defn(backend, alias, main, flags, main_module = None, syntax_module = None):
    flags = [] + flags # Don't modify parameters passed by reference
    flags += ['-I', topdir()]
    if main_module: flags += ['--main-module', main_module]
    if syntax_module: flags += ['--syntax-module', syntax_module]
    return proj.definition( alias = alias
                          , main = main
                          , other = all_sources
                          , backend = backend
                          , flags = ' '.join(flags)
                          )

# Build
# =====

unit_test         = defn('llvm',    'llvm',              'unit-test/unit-test.md',  llvm_flags                 , main_module = 'UNIT-TEST-DRIVER'         , syntax_module = 'UNIT-TEST-SYNTAX'         )
contract_expander = defn('llvm',    'contract-expander', 'compat.md',               llvm_flags                 , main_module = 'CONTRACT-EXPANDER' )
extractor         = defn('llvm',    'extractor',         'compat.md',               llvm_flags                 , main_module = 'EXTRACTOR'         )
input_creator     = defn('llvm',    'input-creator',     'compat.md',               llvm_flags                 , main_module = 'INPUT-CREATOR'     )
output_compare    = defn('llvm',    'output-compare',    'compat.md',               llvm_flags                 , main_module = 'OUTPUT-COMPARE'    )

coverage          = defn('llvm',    'coverage',          'unit-test/unit-test.md',  llvm_flags + ['--coverage']                                    )

prove             = defn('haskell', 'prove',             'unit-test/unit-test.md',  []                                                             )
symbolic          = defn('haskell', 'symbolic',          'symbolic/symbolic.md',    ['--emit-json']            , main_module = 'SYMBOLIC-UNIT-TEST-DRIVER', syntax_module = 'SYMBOLIC-UNIT-TEST-SYNTAX')

proj.alias('defns', [unit_test.target, contract_expander.target, extractor.target, input_creator.target, output_compare.target])

# Test
# ====

def check_unit_test(exit_code, defn, input):
    rule = proj.rule( 'check-unit-test'
                    , description = 'check-unit-test: $in'
                    , command = 'lib/check-exit-code $exit_code lib/michelson-test-check $defn_dir < $in > $out'
                    , ext = 'check'
                    )                                  \
               .variable('exit_code', exit_code) \
               .variable('defn_dir', defn.kompiled_dir()) \
               .implicit([defn.target])
    return input.then(rule)

def kmich(defn, mode, suffix, flags = []):
    rule = proj.rule( 'kmich'
                    , description = 'kmich: $in'
                    , command = './kmich $mode --backend $defn_name $in > $out $flags'
                    )                                \
               .variable('mode', mode)               \
               .variable('defn_name', defn._alias)   \
               .variable('flags', flags)             \
               .implicit([defn.target])              \
               .ext(suffix)
    def runner(input):
        return proj.source(input).then(rule)
    return runner

def cross_test_runner(input):
    rule = proj.rule( 'cross'
                    , description = 'cross: $in'
                    , command = 'lib/tezos-client-unit-test $in > $out'
                    ) \
                    .implicit([ contract_expander.target, extractor.target
                              , input_creator.target, output_compare.target
                             ]) \
                    .ext('cross')
    return proj.source(input).then(rule)


# Unit
# ----

unit_tests_all     = glob('tests/unit/*.tzt')
unit_tests_failing = readlines('tests/failing.unit')
unit_tests_passing = filter_out(unit_tests_all, unit_tests_failing)

unit_test_runner = kmich(unit_test, 'interpret', suffix = 'unit')

proj.suite('test-unit',         unit_tests_passing, unit_test_runner)
proj.suite('test-unit-failing', unit_tests_failing, unit_test_runner, default = False)

# Symbolic
# --------

symbolic_tests_all     = glob('tests/symbolic/*.tzt')
symbolic_tests_failing = readlines('tests/failing.symbolic')
symbolic_tests_passing = filter_out(symbolic_tests_all, symbolic_tests_failing)

def symbolic_test_runner(input):
    json_output = kmich(symbolic, 'run', 'symbolic-json', '--search-final --output json')(input)

    exit_code = 0
    if input.endswith('stuck.tzt'): exit_code = 127
    if input.endswith('fail.tzt'):  exit_code = 1
    check = check_unit_test(exit_code, symbolic, json_output)
    return check

proj.suite('test-symbolic',         symbolic_tests_passing, symbolic_test_runner)
proj.suite('test-symbolic-failing', symbolic_tests_failing, symbolic_test_runner, default = False)

# Prove
# -----

prove_tests_all     = glob('tests/proofs/*-spec.k')
prove_tests_failing = readlines('tests/failing.prove')
prove_tests_passing = filter_out(prove_tests_all, prove_tests_failing)

prove_runner = kmich(prove, 'prove', suffix = 'prove', flags = 'VERIFICATION')

proj.suite('test-prove',         prove_tests_passing, prove_runner)
proj.suite('test-prove-failing', prove_tests_failing, prove_runner, default = False)

# Cross
# -----

cross_tests_all     = glob('tests/unit/*.tzt')
cross_tests_failing = readlines('tests/failing.cross')
cross_tests_passing = filter_out(cross_tests_all, cross_tests_failing)

proj.suite('test-cross',         cross_tests_passing, cross_test_runner)
proj.suite('test-cross-failing', cross_tests_failing, cross_test_runner, default = False)

# Main
# ====

python_path = None
if 'PYTHONPATH' in os.environ: python_path = ':' + os.environ.get('PYTHONPATH')
else: python_path = ''
python_path = proj.klibdir() + python_path
os.environ["PYTHONPATH"] = python_path

proj.main()
